import puppeteer from 'puppeteer';
import * as fs from 'fs';
import * as path from 'path';
import { marked } from 'marked';
import { Section } from '../models';
import { AppConfig } from '../config/app-config';

// Single responsibility: Export summaries to PDF using configurable templates
export class PdfExportService {
  private config: AppConfig;

  constructor(config: AppConfig) {
    this.config = config;
  }
  async exportSummaryToPdf(sections: Section[], filename: string, title: string = 'Document Summary'): Promise<string> {
    const browser = await puppeteer.launch({ headless: true });
    const page = await browser.newPage();

    try {
      // Ensure output directory exists
      if (!fs.existsSync(this.config.outputDirectory)) {
        fs.mkdirSync(this.config.outputDirectory, { recursive: true });
      }

      const outputPath = path.join(this.config.outputDirectory, filename);
      const html = this.generateHtmlFromTemplate(sections, title);

      await page.setContent(html, { waitUntil: 'networkidle0' });

      await page.pdf({
        path: outputPath,
        format: 'A4',
        printBackground: true,
        margin: {
          top: '1cm',
          right: '1cm',
          bottom: '1cm',
          left: '1cm',
        },
      });

      console.log(`PDF exported to: ${outputPath}`);
      return outputPath;
    } finally {
      await browser.close();
    }
  }

  private generateHtmlFromTemplate(sections: Section[], title: string): string {
    const templatePath = path.join(this.config.templateDirectory, 'summary-report.html');
    const cssPath = path.join(this.config.templateDirectory, 'styles.css');

    let template = fs.readFileSync(templatePath, 'utf-8');
    const cssStyles = fs.readFileSync(cssPath, 'utf-8');

    const sectionsHtml = sections.map((section) => this.generateSectionHtml(section)).join('');
    const tocItems = sections.map((section) => `<li><a href="#section-${section.number}">${section.title}</a></li>`).join('');

    const totalSections = sections.length;
    const totalSubSections = sections.reduce((sum, section) => sum + section.subSections.length, 0);

    // Replace template variables
    template = template
      .replace(/{{LANGUAGE}}/g, 'en')
      .replace(/{{DOCUMENT_TITLE}}/g, title)
      .replace(/{{CSS_STYLES}}/g, cssStyles)
      .replace(/{{GENERATION_DATE}}/g, `Generated on: ${new Date().toLocaleDateString()}`)
      .replace(/{{METADATA}}/g, `${totalSections} sections, ${totalSubSections} subsections`)
      .replace(/{{TOC_TITLE}}/g, 'Table of Contents')
      .replace(/{{TOC_ITEMS}}/g, tocItems)
      .replace(/{{CONTENT_SECTIONS}}/g, sectionsHtml)
      .replace(/{{FOOTER_TEXT}}/g, 'Generated by PDF Resumer');

    return template;
  }

  private generateSectionHtml(section: Section): string {
    return `
      <section id="section-${section.number}" class="section">
        <h2>${section.title}</h2>
        
        ${
          section.subSections.length > 0
            ? `
          <div class="subsections">
            <h3>Included lessons:</h3>
            <ul>
              ${section.subSections.map((sub) => `<li>${sub.title} (${sub.content.length} characters)</li>`).join('')}
            </ul>
          </div>
        `
            : ''
        }
        
        ${
          section.summary
            ? `
          <div class="summary">
            <h3>Summary:</h3>
            <div class="summary-content">
              ${this.formatSummaryText(section.summary)}
            </div>
          </div>
        `
            : `<p class="no-summary">Summary not generated</p>`
        }
      </section>
    `;
  }

  private formatSummaryText(summary: string): string {
    // Use marked library to convert markdown to HTML
    try {
      const result = marked(summary, {
        breaks: true, // Convert single line breaks to <br>
        gfm: true, // GitHub Flavored Markdown
      });

      // Handle both sync and async returns from marked
      if (typeof result === 'string') {
        return result;
      } else {
        // If it's a promise, we can't wait for it in sync method, fallback
        console.warn('Marked returned a promise, using plain text fallback');
        return `<p>${summary.replace(/\n/g, '<br>')}</p>`;
      }
    } catch (error) {
      // Fallback to plain text if markdown parsing fails
      console.warn('Markdown parsing failed, using plain text:', error);
      return `<p>${summary.replace(/\n/g, '<br>')}</p>`;
    }
  }
}
